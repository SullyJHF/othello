import { describe, it, expect } from 'vitest';
import { ClientBoardLogic } from './boardLogic';

describe('ClientBoardLogic', () => {
  describe('Complete Game Test - Matches Server-Side Board Test', () => {
    it('should correctly play a valid complete game with exact board state matches', () => {
      let boardState = `........
........
...0....
..0WB...
...BW0..
....0...
........
........`;

      // Move 1: Black plays at position 19
      boardState = ClientBoardLogic.placePiece(boardState, 19, 'B')!;
      boardState = ClientBoardLogic.updateValidMoves(boardState, 'W');
      expect(boardState).toBe(`........
........
..0B0...
...BB...
..0BW...
........
........
........`);

      // Move 2: White plays at position 18
      boardState = ClientBoardLogic.placePiece(boardState, 18, 'W')!;
      boardState = ClientBoardLogic.updateValidMoves(boardState, 'B');
      expect(boardState).toBe(`........
........
.0WB....
..0WB...
...BW0..
....0...
........
........`);

      // Move 3: Black plays at position 44
      boardState = ClientBoardLogic.placePiece(boardState, 44, 'B')!;
      boardState = ClientBoardLogic.updateValidMoves(boardState, 'W');
      expect(boardState).toBe(`........
...0....
..WB0...
...WB0..
...BB...
...0B0..
........
........`);

      // Move 4: White plays at position 29
      boardState = ClientBoardLogic.placePiece(boardState, 29, 'W')!;
      boardState = ClientBoardLogic.updateValidMoves(boardState, 'B');
      expect(boardState).toBe(`........
.0......
.0WB000.
...WWW..
...BB0..
....B...
........
........`);

      // Move 5: Black plays at position 22
      boardState = ClientBoardLogic.placePiece(boardState, 22, 'B')!;
      boardState = ClientBoardLogic.updateValidMoves(boardState, 'W');
      expect(boardState).toBe(`........
..00....
..WB0.B.
...WWB0.
...BB...
..00B0..
....0...
........`);

      // Continue testing several more moves to ensure accuracy
      // Move 6: White plays at position 42
      boardState = ClientBoardLogic.placePiece(boardState, 42, 'W')!;
      boardState = ClientBoardLogic.updateValidMoves(boardState, 'B');
      expect(boardState).toBe(`........
.0......
.0WB0.B.
..0WWB..
..0WB0..
..W0B...
........
........`);

      // Move 7: Black plays at position 9
      boardState = ClientBoardLogic.placePiece(boardState, 9, 'B')!;
      boardState = ClientBoardLogic.updateValidMoves(boardState, 'W');
      expect(boardState).toBe(`........
.B00....
..BB..B.
..0BWB0.
...WB0..
..W.B...
....00..
........`);
    });
  });

  describe('Basic Move Validation', () => {
    it('should place a piece and flip captured pieces correctly', () => {
      const initialBoard = `........
........
...0....
..0WB...
...BW0..
....0...
........
........`;

      const result = ClientBoardLogic.placePiece(initialBoard, 19, 'B');

      expect(result).toBeTruthy();
      expect(result).toContain('B');
      // Should capture the white piece at position 27
      const pieces = result!.replace(/\n/g, '');
      expect(pieces[19]).toBe('B'); // New piece placed
      expect(pieces[27]).toBe('B'); // White piece should be flipped to black
    });

    it('should return null for invalid moves', () => {
      const initialBoard = `........
........
...0....
..0WB...
...BW0..
....0...
........
........`;

      // Try to place on an occupied position
      expect(ClientBoardLogic.placePiece(initialBoard, 27, 'B')).toBeNull();

      // Try to place where no captures are possible
      expect(ClientBoardLogic.placePiece(initialBoard, 0, 'B')).toBeNull();

      // Try to place on invalid position (out of bounds handled by board string)
      expect(ClientBoardLogic.placePiece(initialBoard, 999, 'B')).toBeNull();
    });

    it('should validate moves correctly for both players', () => {
      const initialBoard = `........
........
...0....
..0WB...
...BW0..
....0...
........
........`;

      const blackMoves = ClientBoardLogic.calculateValidMoves(initialBoard, 'B');
      const whiteMoves = ClientBoardLogic.calculateValidMoves(initialBoard, 'W');

      expect(blackMoves.length).toBeGreaterThan(0);
      expect(whiteMoves.length).toBeGreaterThan(0);

      // Standard starting position should have 4 valid moves for each player
      expect(blackMoves).toContain(19); // Top valid move for black
      expect(blackMoves).toContain(26); // Left valid move for black
      expect(blackMoves).toContain(37); // Right valid move for black
      expect(blackMoves).toContain(44); // Bottom valid move for black

      expect(whiteMoves).toContain(20); // Top valid move for white
      expect(whiteMoves).toContain(29); // Right valid move for white
      expect(whiteMoves).toContain(34); // Left valid move for white
      expect(whiteMoves).toContain(43); // Bottom valid move for white
    });
  });

  describe('Score Calculation', () => {
    it('should calculate score correctly for starting position', () => {
      const boardState = `........
........
........
...WB...
...BW...
........
........
........`;

      const score = ClientBoardLogic.calculateScore(boardState);

      expect(score.B).toBe(2);
      expect(score.W).toBe(2);
    });

    it('should calculate score correctly for end game positions', () => {
      const boardState = `BBBBBBBB
BBBBBBBB
BBBBBBBB
BBBBWWWW
BBBBWWWW
BBBBWWWW
BBBBWWWW
BBBBWWWW`;

      const score = ClientBoardLogic.calculateScore(boardState);

      // Count actual pieces: 3 full rows of B (24) + 4 B's on next 5 rows (20) = 44 B's
      // And 5 rows with 4 W's each = 20 W's
      expect(score.B).toBe(44);
      expect(score.W).toBe(20);
    });

    it('should handle empty board', () => {
      const boardState = `........
........
........
........
........
........
........
........`;

      const score = ClientBoardLogic.calculateScore(boardState);

      expect(score.B).toBe(0);
      expect(score.W).toBe(0);
    });
  });

  describe('Valid Move Markers', () => {
    it('should mark valid moves with 0 for starting position', () => {
      const boardState = `........
........
........
...WB...
...BW...
........
........
........`;

      const updatedBoard = ClientBoardLogic.updateValidMoves(boardState, 'B');

      expect(updatedBoard).toContain('0');

      // Should contain exactly 4 valid moves marked with '0'
      const moveCount = (updatedBoard.match(/0/g) || []).length;
      expect(moveCount).toBe(4);
    });

    it('should clear existing move markers before adding new ones', () => {
      const boardState = `........
........
...0....
..0WB0..
...BW0..
....0...
........
........`;

      const updatedBoard = ClientBoardLogic.updateValidMoves(boardState, 'W');

      // Should not have the old move markers in the same positions
      expect(updatedBoard).not.toBe(boardState);
      expect(updatedBoard).toContain('0');
    });

    it('should handle positions with no valid moves', () => {
      // Create a board state where one player has no valid moves
      const boardState = `WWWWWWWW
WWWWWWWW
WWWWWWWW
WWWWWWWW
WWWWWWWW
WWWWWWWW
WWWWWWWW
WWWWWWW.`;

      const updatedBoard = ClientBoardLogic.updateValidMoves(boardState, 'B');

      // Black should have no valid moves in this position
      const moveCount = (updatedBoard.match(/0/g) || []).length;
      expect(moveCount).toBe(0);
    });
  });

  describe('Direction Checking', () => {
    it('should check all 8 directions correctly', () => {
      // Create a position where pieces can be captured in multiple directions
      const boardState = `........
.WWW....
.WBW....
.WWW....
........
........
........
........`;

      // Create a valid Othello position with standard starting setup
      const validBoard = `........
........
........
...WB...
...BW...
........
........
........`;

      const result = ClientBoardLogic.placePiece(validBoard, 26, 'B'); // Center position

      expect(result).toBeTruthy();
      // Should capture the W piece horizontally
      const pieces = result!.replace(/\n/g, '');
      expect(pieces[26]).toBe('B'); // The placed piece
      expect(pieces[27]).toBe('B'); // Should capture the W piece horizontally
    });

    it('should handle edge cases near board boundaries', () => {
      // Test moves near the edge of the board
      const boardState = `WB......
WB......
........
........
........
........
........
........`;

      // Create a valid board position near the edge
      const edgeBoard = `........
........
........
..WB....
...BW...
........
........
........`;

      const result = ClientBoardLogic.placePiece(edgeBoard, 25, 'B'); // Place near edge

      expect(result).toBeTruthy();
      const pieces = result!.replace(/\n/g, '');
      expect(pieces[25]).toBe('B'); // The placed piece
      expect(pieces[26]).toBe('B'); // Should capture the W piece
    });
  });

  describe('Edge Cases and Error Handling', () => {
    it('should handle moves at board corners', () => {
      const boardState = `WB......
........
........
........
........
........
........
........`;

      // Try to place at corner position 0
      const result = ClientBoardLogic.placePiece(boardState, 0, 'B');
      expect(result).toBeNull(); // Should be invalid as it can't capture anything
    });

    it('should handle single piece scenarios', () => {
      const boardState = `B.......
........
........
........
........
........
........
........`;

      const validMoves = ClientBoardLogic.calculateValidMoves(boardState, 'W');
      expect(validMoves.length).toBe(0); // No valid moves for white
    });

    it('should handle completely filled board', () => {
      const boardState = `BBBBBBBB
BBBBBBBB
BBBBBBBB
BBBBBBBB
BBBBBBBB
BBBBBBBB
BBBBBBBB
BBBBBBBB`;

      const validMoves = ClientBoardLogic.calculateValidMoves(boardState, 'W');
      expect(validMoves.length).toBe(0);

      const result = ClientBoardLogic.placePiece(boardState, 0, 'W');
      expect(result).toBeNull();
    });

    it('should handle malformed board states gracefully', () => {
      // Test with shorter board string
      const shortBoard = `....
....`;

      expect(() => {
        ClientBoardLogic.calculateValidMoves(shortBoard, 'B');
      }).not.toThrow();

      // Test with invalid characters
      const invalidBoard = `........
........
...XY...
...WB...
...BW...
........
........
........`;

      const result = ClientBoardLogic.calculateScore(invalidBoard);
      expect(result.B).toBe(2);
      expect(result.W).toBe(2);
    });
  });

  describe('Complex Game Scenarios', () => {
    it('should handle multiple captures in one move', () => {
      // Setup a position where one move captures multiple pieces
      const boardState = `........
........
BBB.....
WWWB....
BBBB....
........
........
........`;

      // Create a valid board position where one move can capture multiple pieces
      const validBoard = `........
........
........
..WWWB..
...BW...
........
........
........`;

      const result = ClientBoardLogic.placePiece(validBoard, 25, 'B'); // Should capture multiple W pieces

      expect(result).toBeTruthy();
      const score = ClientBoardLogic.calculateScore(result!);
      expect(score.B).toBeGreaterThan(score.W);
    });

    it('should handle chain reactions correctly', () => {
      // Test a move that creates opportunities for future moves
      const boardState = `........
........
...0....
..0WB...
...BW0..
....0...
........
........`;

      let currentBoard = ClientBoardLogic.placePiece(boardState, 19, 'B')!;
      currentBoard = ClientBoardLogic.updateValidMoves(currentBoard, 'W');

      const whiteMoves = ClientBoardLogic.calculateValidMoves(currentBoard, 'W');
      expect(whiteMoves.length).toBeGreaterThan(0);

      // Make a white move
      currentBoard = ClientBoardLogic.placePiece(currentBoard, whiteMoves[0], 'W')!;
      currentBoard = ClientBoardLogic.updateValidMoves(currentBoard, 'B');

      const blackMoves = ClientBoardLogic.calculateValidMoves(currentBoard, 'B');
      expect(blackMoves.length).toBeGreaterThan(0);
    });

    it('should maintain game state consistency throughout long games', () => {
      let boardState = `........
........
...0....
..0WB...
...BW0..
....0...
........
........`;

      let moveCount = 0;
      let currentPlayer: 'B' | 'W' = 'B';

      // Play several moves and ensure board state remains valid
      while (moveCount < 10) {
        const validMoves = ClientBoardLogic.calculateValidMoves(boardState, currentPlayer);

        if (validMoves.length === 0) break;

        // Make the first valid move
        const newBoard = ClientBoardLogic.placePiece(boardState, validMoves[0], currentPlayer);
        expect(newBoard).toBeTruthy();

        boardState = ClientBoardLogic.updateValidMoves(newBoard!, currentPlayer === 'B' ? 'W' : 'B');
        currentPlayer = currentPlayer === 'B' ? 'W' : 'B';
        moveCount++;
      }

      // Verify final state has valid score
      const finalScore = ClientBoardLogic.calculateScore(boardState);
      expect(finalScore.B + finalScore.W).toBeGreaterThan(4); // Should have more pieces than start
    });
  });

  describe('Performance and Memory', () => {
    it('should handle rapid successive move calculations', () => {
      const boardState = `........
........
...0....
..0WB...
...BW0..
....0...
........
........`;

      const startTime = Date.now();

      // Perform many calculations rapidly
      for (let i = 0; i < 1000; i++) {
        ClientBoardLogic.calculateValidMoves(boardState, 'B');
        ClientBoardLogic.calculateScore(boardState);
      }

      const endTime = Date.now();
      expect(endTime - startTime).toBeLessThan(1000); // Should complete within 1 second
    });

    it('should not mutate input board state', () => {
      const originalBoard = `........
........
...0....
..0WB...
...BW0..
....0...
........
........`;

      const boardCopy = originalBoard;

      ClientBoardLogic.placePiece(originalBoard, 19, 'B');
      ClientBoardLogic.calculateValidMoves(originalBoard, 'B');
      ClientBoardLogic.updateValidMoves(originalBoard, 'B');

      expect(originalBoard).toBe(boardCopy); // Original should be unchanged
    });
  });
});
